// SPDX-License-Identifier: MIT
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("PrivateTransaction Contract", function () {
    let PrivateTransaction;
    let privateTransaction;
    let owner;
    let addr1;

    // Sample proof data (replace with actual proof data generated by ZoKrates)
    const proofA = [/* a[0], a[1] */];
    const proofB = [/* b[0][0], b[0][1], b[1][0], b[1][1] */];
    const proofC = [/* c[0], c[1] */];
    const input = [/* public input */];

    beforeEach(async function () {
        // Get the ContractFactory and Signers here.
        PrivateTransaction = await ethers.getContractFactory("PrivateTransaction");
        [owner, addr1] = await ethers.getSigners();

        // Deploy a new PrivateTransaction contract for each test
        privateTransaction = await PrivateTransaction.deploy();
        await privateTransaction.deployed();
    });

    describe("Verify Transaction", function () {
        it("Should verify a valid proof", async function () {
            await expect(privateTransaction.verifyTransaction(proofA, proofB, proofC, input))
                .to.emit(privateTransaction, "TransactionVerified")
                .withArgs(owner.address, input[0], await ethers.provider.getBlock("latest").then(block => block.timestamp));
        });

        it("Should fail to verify an invalid proof", async function () {
            const invalidProofA = [/* invalid a[0], a[1] */];
            await expect(privateTransaction.verifyTransaction(invalidProofA, proofB, proofC, input)).to.be.revertedWith("Invalid proof");
        });

        it("Should prevent replay attacks", async function () {
            await privateTransaction.verifyTransaction(proofA, proofB, proofC, input);
            await expect(privateTransaction.verifyTransaction(proofA, proofB, proofC, input)).to.be.revertedWith("Proof has already been used");
        });
    });

    describe("Reset Used Proofs", function () {
        it("Should allow the owner to reset used proofs", async function () {
            await privateTransaction.verifyTransaction(proofA, proofB, proofC, input);
            await privateTransaction.resetUsedProofs();
            await expect(privateTransaction.verifyTransaction(proofA, proofB, proofC, input))
                .to.emit(privateTransaction, "TransactionVerified")
                .withArgs(owner.address, input[0], await ethers.provider.getBlock("latest").then(block => block.timestamp));
        });

        it("Should not allow non-owners to reset used proofs", async function () {
            await expect(privateTransaction.connect(addr1).resetUsedProofs()).to.be.revertedWith("Ownable: caller is not the owner");
        });
    });
});
